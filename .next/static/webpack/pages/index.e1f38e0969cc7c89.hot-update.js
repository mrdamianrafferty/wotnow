"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./utils/activityScoring.ts":
/*!**********************************!*\
  !*** ./utils/activityScoring.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateActivityScore: () => (/* binding */ calculateActivityScore)\n/* harmony export */ });\n/* harmony import */ var _activitySuitability__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activitySuitability */ \"(pages-dir-browser)/./utils/activitySuitability.ts\");\n\nfunction calculateActivityScore(activity, weather, isWeatherGood, isEvening) {\n    if (!activity.weatherSensitive) {\n        // Penalize indoor activities if weather is good and NOT evening\n        if (isWeatherGood && !isEvening) {\n            return 20; // Lower base score for indoor activities\n        }\n        return 50; // Normal base score for indoor activities\n    }\n    // Calculate condition match scores (0-1 range)\n    const perfectScore = calculateConditionMatchScore(activity.perfectConditions || [], weather);\n    const goodScore = calculateConditionMatchScore(activity.goodConditions || [], weather);\n    const poorPenalty = calculatePoorConditionPenalty(activity.poorConditions || [], weather);\n    let baseScore = 25; // Minimum for viable activities\n    if (perfectScore >= 0.8) {\n        baseScore = 80 + perfectScore * 20; // 80-100 range\n    } else if (goodScore >= 0.6) {\n        baseScore = 60 + goodScore * 20; // 60-80 range  \n    } else if (perfectScore >= 0.4 || goodScore >= 0.4) {\n        baseScore = 30 + Math.max(perfectScore, goodScore) * 30; // 30-60 range\n    }\n    // Apply poor condition penalties\n    baseScore = Math.max(0, baseScore - poorPenalty * 40);\n    return Math.round(baseScore);\n}\nfunction calculateConditionMatchScore(conditions, weather) {\n    if (conditions.length === 0) return 0;\n    let totalScore = 0;\n    let evaluatedConditions = 0;\n    for (const condition of conditions){\n        const score = (0,_activitySuitability__WEBPACK_IMPORTED_MODULE_0__.evaluateConditionScore)(condition, weather);\n        if (score >= 0) {\n            totalScore += score;\n            evaluatedConditions++;\n        }\n    }\n    return evaluatedConditions > 0 ? totalScore / evaluatedConditions : 0;\n}\nfunction calculatePoorConditionPenalty(conditions, weather) {\n    if (conditions.length === 0) return 0;\n    let penalties = 0;\n    for (const condition of conditions){\n        if ((0,_activitySuitability__WEBPACK_IMPORTED_MODULE_0__.evaluateConditionScore)(condition, weather) > 0.7) {\n            penalties += 1;\n        }\n    }\n    return Math.min(1, penalties / conditions.length);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL2FjdGl2aXR5U2NvcmluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUVxRjtBQUU5RSxTQUFTQyx1QkFDZEMsUUFBc0IsRUFDdEJDLE9BQW9CLEVBQ3BCQyxhQUFzQixFQUN0QkMsU0FBa0I7SUFFbEIsSUFBSSxDQUFDSCxTQUFTSSxnQkFBZ0IsRUFBRTtRQUM5QixnRUFBZ0U7UUFDaEUsSUFBSUYsaUJBQWlCLENBQUNDLFdBQVc7WUFDL0IsT0FBTyxJQUFJLHlDQUF5QztRQUN0RDtRQUNBLE9BQU8sSUFBSSwwQ0FBMEM7SUFDdkQ7SUFFQSwrQ0FBK0M7SUFDL0MsTUFBTUUsZUFBZUMsNkJBQTZCTixTQUFTTyxpQkFBaUIsSUFBSSxFQUFFLEVBQUVOO0lBQ3BGLE1BQU1PLFlBQVlGLDZCQUE2Qk4sU0FBU1MsY0FBYyxJQUFJLEVBQUUsRUFBRVI7SUFDOUUsTUFBTVMsY0FBY0MsOEJBQThCWCxTQUFTWSxjQUFjLElBQUksRUFBRSxFQUFFWDtJQUVqRixJQUFJWSxZQUFZLElBQUksZ0NBQWdDO0lBRXBELElBQUlSLGdCQUFnQixLQUFLO1FBQ3ZCUSxZQUFZLEtBQU1SLGVBQWUsSUFBSyxlQUFlO0lBQ3ZELE9BQU8sSUFBSUcsYUFBYSxLQUFLO1FBQzNCSyxZQUFZLEtBQU1MLFlBQVksSUFBSyxnQkFBZ0I7SUFDckQsT0FBTyxJQUFJSCxnQkFBZ0IsT0FBT0csYUFBYSxLQUFLO1FBQ2xESyxZQUFZLEtBQUtDLEtBQUtDLEdBQUcsQ0FBQ1YsY0FBY0csYUFBYSxJQUFJLGNBQWM7SUFDekU7SUFFQSxpQ0FBaUM7SUFDakNLLFlBQVlDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRixZQUFhSCxjQUFjO0lBQ25ELE9BQU9JLEtBQUtFLEtBQUssQ0FBQ0g7QUFDcEI7QUFFQSxTQUFTUCw2QkFBNkJXLFVBQW9CLEVBQUVoQixPQUFvQjtJQUM5RSxJQUFJZ0IsV0FBV0MsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUVwQyxJQUFJQyxhQUFhO0lBQ2pCLElBQUlDLHNCQUFzQjtJQUUxQixLQUFLLE1BQU1DLGFBQWFKLFdBQVk7UUFDbEMsTUFBTUssUUFBUXhCLDRFQUFzQkEsQ0FBQ3VCLFdBQVdwQjtRQUNoRCxJQUFJcUIsU0FBUyxHQUFHO1lBQ2RILGNBQWNHO1lBQ2RGO1FBQ0Y7SUFDRjtJQUVBLE9BQU9BLHNCQUFzQixJQUFJRCxhQUFhQyxzQkFBc0I7QUFDdEU7QUFFQSxTQUFTVCw4QkFBOEJNLFVBQW9CLEVBQUVoQixPQUFvQjtJQUMvRSxJQUFJZ0IsV0FBV0MsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUVwQyxJQUFJSyxZQUFZO0lBQ2hCLEtBQUssTUFBTUYsYUFBYUosV0FBWTtRQUNsQyxJQUFJbkIsNEVBQXNCQSxDQUFDdUIsV0FBV3BCLFdBQVcsS0FBSztZQUNwRHNCLGFBQWE7UUFDZjtJQUNGO0lBRUEsT0FBT1QsS0FBS1UsR0FBRyxDQUFDLEdBQUdELFlBQVlOLFdBQVdDLE1BQU07QUFDbEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYW1pYW5yYWZmZXJ0eS9Qcm9qZWN0cy9Xb3ROb3cvdXRpbHMvYWN0aXZpdHlTY29yaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdlYXRoZXJEYXRhIH0gZnJvbSAnLi93ZWF0aGVyVHlwZXMnO1xuaW1wb3J0IHsgQWN0aXZpdHlUeXBlIH0gZnJvbSAnLi4vZGF0YS9hY3Rpdml0eVR5cGVzJztcbmltcG9ydCB7IGV2YWx1YXRlQ29uZGl0aW9uU2NvcmUsIHBhcnNlQ29uZGl0aW9uU3RyaW5nIH0gZnJvbSAnLi9hY3Rpdml0eVN1aXRhYmlsaXR5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFjdGl2aXR5U2NvcmUoXG4gIGFjdGl2aXR5OiBBY3Rpdml0eVR5cGUsXG4gIHdlYXRoZXI6IFdlYXRoZXJEYXRhLFxuICBpc1dlYXRoZXJHb29kOiBib29sZWFuLFxuICBpc0V2ZW5pbmc6IGJvb2xlYW5cbik6IG51bWJlciB7XG4gIGlmICghYWN0aXZpdHkud2VhdGhlclNlbnNpdGl2ZSkge1xuICAgIC8vIFBlbmFsaXplIGluZG9vciBhY3Rpdml0aWVzIGlmIHdlYXRoZXIgaXMgZ29vZCBhbmQgTk9UIGV2ZW5pbmdcbiAgICBpZiAoaXNXZWF0aGVyR29vZCAmJiAhaXNFdmVuaW5nKSB7XG4gICAgICByZXR1cm4gMjA7IC8vIExvd2VyIGJhc2Ugc2NvcmUgZm9yIGluZG9vciBhY3Rpdml0aWVzXG4gICAgfVxuICAgIHJldHVybiA1MDsgLy8gTm9ybWFsIGJhc2Ugc2NvcmUgZm9yIGluZG9vciBhY3Rpdml0aWVzXG4gIH1cblxuICAvLyBDYWxjdWxhdGUgY29uZGl0aW9uIG1hdGNoIHNjb3JlcyAoMC0xIHJhbmdlKVxuICBjb25zdCBwZXJmZWN0U2NvcmUgPSBjYWxjdWxhdGVDb25kaXRpb25NYXRjaFNjb3JlKGFjdGl2aXR5LnBlcmZlY3RDb25kaXRpb25zIHx8IFtdLCB3ZWF0aGVyKTtcbiAgY29uc3QgZ29vZFNjb3JlID0gY2FsY3VsYXRlQ29uZGl0aW9uTWF0Y2hTY29yZShhY3Rpdml0eS5nb29kQ29uZGl0aW9ucyB8fCBbXSwgd2VhdGhlcik7XG4gIGNvbnN0IHBvb3JQZW5hbHR5ID0gY2FsY3VsYXRlUG9vckNvbmRpdGlvblBlbmFsdHkoYWN0aXZpdHkucG9vckNvbmRpdGlvbnMgfHwgW10sIHdlYXRoZXIpO1xuXG4gIGxldCBiYXNlU2NvcmUgPSAyNTsgLy8gTWluaW11bSBmb3IgdmlhYmxlIGFjdGl2aXRpZXNcblxuICBpZiAocGVyZmVjdFNjb3JlID49IDAuOCkge1xuICAgIGJhc2VTY29yZSA9IDgwICsgKHBlcmZlY3RTY29yZSAqIDIwKTsgLy8gODAtMTAwIHJhbmdlXG4gIH0gZWxzZSBpZiAoZ29vZFNjb3JlID49IDAuNikge1xuICAgIGJhc2VTY29yZSA9IDYwICsgKGdvb2RTY29yZSAqIDIwKTsgLy8gNjAtODAgcmFuZ2UgIFxuICB9IGVsc2UgaWYgKHBlcmZlY3RTY29yZSA+PSAwLjQgfHwgZ29vZFNjb3JlID49IDAuNCkge1xuICAgIGJhc2VTY29yZSA9IDMwICsgTWF0aC5tYXgocGVyZmVjdFNjb3JlLCBnb29kU2NvcmUpICogMzA7IC8vIDMwLTYwIHJhbmdlXG4gIH1cblxuICAvLyBBcHBseSBwb29yIGNvbmRpdGlvbiBwZW5hbHRpZXNcbiAgYmFzZVNjb3JlID0gTWF0aC5tYXgoMCwgYmFzZVNjb3JlIC0gKHBvb3JQZW5hbHR5ICogNDApKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoYmFzZVNjb3JlKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29uZGl0aW9uTWF0Y2hTY29yZShjb25kaXRpb25zOiBzdHJpbmdbXSwgd2VhdGhlcjogV2VhdGhlckRhdGEpOiBudW1iZXIge1xuICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICBcbiAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuICBsZXQgZXZhbHVhdGVkQ29uZGl0aW9ucyA9IDA7XG4gIFxuICBmb3IgKGNvbnN0IGNvbmRpdGlvbiBvZiBjb25kaXRpb25zKSB7XG4gICAgY29uc3Qgc2NvcmUgPSBldmFsdWF0ZUNvbmRpdGlvblNjb3JlKGNvbmRpdGlvbiwgd2VhdGhlcik7XG4gICAgaWYgKHNjb3JlID49IDApIHtcbiAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG4gICAgICBldmFsdWF0ZWRDb25kaXRpb25zKys7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZXZhbHVhdGVkQ29uZGl0aW9ucyA+IDAgPyB0b3RhbFNjb3JlIC8gZXZhbHVhdGVkQ29uZGl0aW9ucyA6IDA7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvb3JDb25kaXRpb25QZW5hbHR5KGNvbmRpdGlvbnM6IHN0cmluZ1tdLCB3ZWF0aGVyOiBXZWF0aGVyRGF0YSk6IG51bWJlciB7XG4gIGlmIChjb25kaXRpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gIFxuICBsZXQgcGVuYWx0aWVzID0gMDtcbiAgZm9yIChjb25zdCBjb25kaXRpb24gb2YgY29uZGl0aW9ucykge1xuICAgIGlmIChldmFsdWF0ZUNvbmRpdGlvblNjb3JlKGNvbmRpdGlvbiwgd2VhdGhlcikgPiAwLjcpIHtcbiAgICAgIHBlbmFsdGllcyArPSAxO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIE1hdGgubWluKDEsIHBlbmFsdGllcyAvIGNvbmRpdGlvbnMubGVuZ3RoKTtcbn1cbiJdLCJuYW1lcyI6WyJldmFsdWF0ZUNvbmRpdGlvblNjb3JlIiwiY2FsY3VsYXRlQWN0aXZpdHlTY29yZSIsImFjdGl2aXR5Iiwid2VhdGhlciIsImlzV2VhdGhlckdvb2QiLCJpc0V2ZW5pbmciLCJ3ZWF0aGVyU2Vuc2l0aXZlIiwicGVyZmVjdFNjb3JlIiwiY2FsY3VsYXRlQ29uZGl0aW9uTWF0Y2hTY29yZSIsInBlcmZlY3RDb25kaXRpb25zIiwiZ29vZFNjb3JlIiwiZ29vZENvbmRpdGlvbnMiLCJwb29yUGVuYWx0eSIsImNhbGN1bGF0ZVBvb3JDb25kaXRpb25QZW5hbHR5IiwicG9vckNvbmRpdGlvbnMiLCJiYXNlU2NvcmUiLCJNYXRoIiwibWF4Iiwicm91bmQiLCJjb25kaXRpb25zIiwibGVuZ3RoIiwidG90YWxTY29yZSIsImV2YWx1YXRlZENvbmRpdGlvbnMiLCJjb25kaXRpb24iLCJzY29yZSIsInBlbmFsdGllcyIsIm1pbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/activityScoring.ts\n"));

/***/ })

});