"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./utils/activitySuitability.ts":
/*!**************************************!*\
  !*** ./utils/activitySuitability.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluateCondition: () => (/* binding */ evaluateCondition),\n/* harmony export */   extractWeatherKey: () => (/* binding */ extractWeatherKey),\n/* harmony export */   getActivitySuitability: () => (/* binding */ getActivitySuitability),\n/* harmony export */   hasGoodConditions: () => (/* binding */ hasGoodConditions),\n/* harmony export */   hasPerfectConditions: () => (/* binding */ hasPerfectConditions),\n/* harmony export */   hasPoorCondition: () => (/* binding */ hasPoorCondition),\n/* harmony export */   parseConditionString: () => (/* binding */ parseConditionString),\n/* harmony export */   safeEvaluate: () => (/* binding */ safeEvaluate)\n/* harmony export */ });\n// utils/activitySuitability.ts\n/**\n * Extracts the weather key name from a condition string.\n * (e.g., \"temperature>15\" -> \"temperature\")\n */ function extractWeatherKey(condition) {\n    const rangeMatch = condition.match(/^([a-zA-Z_]+)=(-?\\d+(?:\\.\\d+)?)\\.\\.(-?\\d+(?:\\.\\d+)?)/);\n    if (rangeMatch) return rangeMatch[1];\n    const opMatch = condition.match(/^([a-zA-Z_]+)[<>=!]=?/);\n    if (opMatch) return opMatch[1];\n    return condition;\n}\n/**\n * Parses a condition string into key/operator/value\n */ function parseConditionString(condition) {\n    const rangeMatch = condition.match(/^([a-zA-Z_]+)=(-?\\d+(?:\\.\\d+)?)\\.\\.(-?\\d+(?:\\.\\d+)?)/);\n    if (rangeMatch) {\n        return {\n            key: rangeMatch[1],\n            operator: 'range',\n            min: parseFloat(rangeMatch[2]),\n            max: parseFloat(rangeMatch[3])\n        };\n    }\n    const opMatch = condition.match(/^([a-zA-Z_]+)([<>=!]=?|==)(-?\\d+(?:\\.\\d+)?)/);\n    if (opMatch) {\n        return {\n            key: opMatch[1],\n            operator: opMatch[2],\n            value: parseFloat(opMatch[3])\n        };\n    }\n    return null;\n}\n/**\n * Evaluates a parsed condition against weather\n */ function evaluateCondition(condition, weather) {\n    const parsed = parseConditionString(condition);\n    if (!parsed) return false;\n    const weatherValue = weather[parsed.key];\n    if (weatherValue === undefined || weatherValue === null) return false;\n    if (parsed.operator === 'range') {\n        return weatherValue >= parsed.min && weatherValue <= parsed.max;\n    }\n    switch(parsed.operator){\n        case '>':\n            return weatherValue > parsed.value;\n        case '>=':\n            return weatherValue >= parsed.value;\n        case '<':\n            return weatherValue < parsed.value;\n        case '<=':\n            return weatherValue <= parsed.value;\n        case '=':\n        case '==':\n            return weatherValue === parsed.value;\n        case '!=':\n            return weatherValue !== parsed.value;\n        default:\n            console.warn(\"Unknown operator: \".concat(parsed.operator));\n            return false;\n    }\n}\n/**\n * Gracefully evaluates a condition, skipping missing weather fields.\n */ function safeEvaluate(condition, weather) {\n    const key = extractWeatherKey(condition);\n    const value = weather[key];\n    if (value === undefined || value === null) return true; // Treat missing fields as neutral\n    return evaluateCondition(condition, weather);\n}\n/**\n * Returns true if any poor condition matches.\n */ function hasPoorCondition(activity, weather) {\n    var _activity_poorConditions;\n    return !!((_activity_poorConditions = activity.poorConditions) === null || _activity_poorConditions === void 0 ? void 0 : _activity_poorConditions.some((cond)=>safeEvaluate(cond, weather)));\n}\n/**\n * Returns true if all perfect conditions with known weather keys match.\n */ function hasPerfectConditions(activity, weather) {\n    var _activity_perfectConditions;\n    return !!((_activity_perfectConditions = activity.perfectConditions) === null || _activity_perfectConditions === void 0 ? void 0 : _activity_perfectConditions.length) && activity.perfectConditions.every((cond)=>safeEvaluate(cond, weather));\n}\n/**\n * Returns true if all good conditions with known weather keys match.\n */ function hasGoodConditions(activity, weather) {\n    var _activity_goodConditions;\n    return !!((_activity_goodConditions = activity.goodConditions) === null || _activity_goodConditions === void 0 ? void 0 : _activity_goodConditions.length) && activity.goodConditions.every((cond)=>safeEvaluate(cond, weather));\n}\n/**\n * Returns the suitability level of an activity for the given weather.\n */ function getActivitySuitability(activity, weather) {\n    if (activity.weatherSensitive === false) return \"indoor\";\n    if (hasPoorCondition(activity, weather)) return \"excluded\";\n    if (hasPerfectConditions(activity, weather)) return \"perfect\";\n    if (hasGoodConditions(activity, weather)) return \"good\";\n    if ((!activity.goodConditions || activity.goodConditions.length === 0) && (!activity.perfectConditions || activity.perfectConditions.length === 0)) {\n        return \"acceptable\";\n    }\n    return \"excluded\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL2FjdGl2aXR5U3VpdGFiaWxpdHkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUF3Qi9COzs7Q0FHQyxHQUNNLFNBQVNBLGtCQUFrQkMsU0FBaUI7SUFDakQsTUFBTUMsYUFBYUQsVUFBVUUsS0FBSyxDQUFDO0lBQ25DLElBQUlELFlBQVksT0FBT0EsVUFBVSxDQUFDLEVBQUU7SUFDcEMsTUFBTUUsVUFBVUgsVUFBVUUsS0FBSyxDQUFDO0lBQ2hDLElBQUlDLFNBQVMsT0FBT0EsT0FBTyxDQUFDLEVBQUU7SUFDOUIsT0FBT0g7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU0kscUJBQXFCSixTQUFpQjtJQUNwRCxNQUFNQyxhQUFhRCxVQUFVRSxLQUFLLENBQUM7SUFDbkMsSUFBSUQsWUFBWTtRQUNkLE9BQU87WUFDTEksS0FBS0osVUFBVSxDQUFDLEVBQUU7WUFDbEJLLFVBQVU7WUFDVkMsS0FBS0MsV0FBV1AsVUFBVSxDQUFDLEVBQUU7WUFDN0JRLEtBQUtELFdBQVdQLFVBQVUsQ0FBQyxFQUFFO1FBQy9CO0lBQ0Y7SUFDQSxNQUFNRSxVQUFVSCxVQUFVRSxLQUFLLENBQUM7SUFDaEMsSUFBSUMsU0FBUztRQUNYLE9BQU87WUFDTEUsS0FBS0YsT0FBTyxDQUFDLEVBQUU7WUFDZkcsVUFBVUgsT0FBTyxDQUFDLEVBQUU7WUFDcEJPLE9BQU9GLFdBQVdMLE9BQU8sQ0FBQyxFQUFFO1FBQzlCO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNRLGtCQUFrQlgsU0FBaUIsRUFBRVksT0FBb0I7SUFDdkUsTUFBTUMsU0FBU1QscUJBQXFCSjtJQUNwQyxJQUFJLENBQUNhLFFBQVEsT0FBTztJQUVwQixNQUFNQyxlQUFlRixPQUFPLENBQUNDLE9BQU9SLEdBQUcsQ0FBQztJQUN4QyxJQUFJUyxpQkFBaUJDLGFBQWFELGlCQUFpQixNQUFNLE9BQU87SUFFaEUsSUFBSUQsT0FBT1AsUUFBUSxLQUFLLFNBQVM7UUFDL0IsT0FBT1EsZ0JBQWdCRCxPQUFPTixHQUFHLElBQUlPLGdCQUFnQkQsT0FBT0osR0FBRztJQUNqRTtJQUVBLE9BQVFJLE9BQU9QLFFBQVE7UUFDckIsS0FBSztZQUNILE9BQU9RLGVBQWVELE9BQU9ILEtBQUs7UUFDcEMsS0FBSztZQUNILE9BQU9JLGdCQUFnQkQsT0FBT0gsS0FBSztRQUNyQyxLQUFLO1lBQ0gsT0FBT0ksZUFBZUQsT0FBT0gsS0FBSztRQUNwQyxLQUFLO1lBQ0gsT0FBT0ksZ0JBQWdCRCxPQUFPSCxLQUFLO1FBQ3JDLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT0ksaUJBQWlCRCxPQUFPSCxLQUFLO1FBQ3RDLEtBQUs7WUFDSCxPQUFPSSxpQkFBaUJELE9BQU9ILEtBQUs7UUFDdEM7WUFDRU0sUUFBUUMsSUFBSSxDQUFDLHFCQUFxQyxPQUFoQkosT0FBT1AsUUFBUTtZQUNqRCxPQUFPO0lBQ1g7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU1ksYUFBYWxCLFNBQWlCLEVBQUVZLE9BQW9CO0lBQ2xFLE1BQU1QLE1BQU1OLGtCQUFrQkM7SUFDOUIsTUFBTVUsUUFBUUUsT0FBTyxDQUFDUCxJQUFJO0lBQzFCLElBQUlLLFVBQVVLLGFBQWFMLFVBQVUsTUFBTSxPQUFPLE1BQU0sa0NBQWtDO0lBQzFGLE9BQU9DLGtCQUFrQlgsV0FBV1k7QUFDdEM7QUFFQTs7Q0FFQyxHQUNNLFNBQVNPLGlCQUFpQkMsUUFBdUMsRUFBRVIsT0FBb0I7UUFDbkZRO0lBQVQsT0FBTyxDQUFDLEdBQUNBLDJCQUFBQSxTQUFTQyxjQUFjLGNBQXZCRCwrQ0FBQUEseUJBQXlCRSxJQUFJLENBQUNDLENBQUFBLE9BQVFMLGFBQWFLLE1BQU1YO0FBQ3BFO0FBRUE7O0NBRUMsR0FDTSxTQUFTWSxxQkFBcUJKLFFBQTBDLEVBQUVSLE9BQW9CO1FBQzFGUTtJQUFULE9BQU8sQ0FBQyxHQUFDQSw4QkFBQUEsU0FBU0ssaUJBQWlCLGNBQTFCTCxrREFBQUEsNEJBQTRCTSxNQUFNLEtBQ3pDTixTQUFTSyxpQkFBaUIsQ0FBQ0UsS0FBSyxDQUFDSixDQUFBQSxPQUFRTCxhQUFhSyxNQUFNWDtBQUNoRTtBQUVBOztDQUVDLEdBQ00sU0FBU2dCLGtCQUFrQlIsUUFBdUMsRUFBRVIsT0FBb0I7UUFDcEZRO0lBQVQsT0FBTyxDQUFDLEdBQUNBLDJCQUFBQSxTQUFTUyxjQUFjLGNBQXZCVCwrQ0FBQUEseUJBQXlCTSxNQUFNLEtBQ3RDTixTQUFTUyxjQUFjLENBQUNGLEtBQUssQ0FBQ0osQ0FBQUEsT0FBUUwsYUFBYUssTUFBTVg7QUFDN0Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNrQix1QkFDZFYsUUFBYSxFQUNiUixPQUFvQjtJQUVwQixJQUFJUSxTQUFTVyxnQkFBZ0IsS0FBSyxPQUFPLE9BQU87SUFDaEQsSUFBSVosaUJBQWlCQyxVQUFVUixVQUFVLE9BQU87SUFDaEQsSUFBSVkscUJBQXFCSixVQUFVUixVQUFVLE9BQU87SUFDcEQsSUFBSWdCLGtCQUFrQlIsVUFBVVIsVUFBVSxPQUFPO0lBQ2pELElBQ0UsQ0FBQyxDQUFDUSxTQUFTUyxjQUFjLElBQUlULFNBQVNTLGNBQWMsQ0FBQ0gsTUFBTSxLQUFLLE1BQy9ELEVBQUNOLFNBQVNLLGlCQUFpQixJQUFJTCxTQUFTSyxpQkFBaUIsQ0FBQ0MsTUFBTSxLQUFLLElBQ3RFO1FBQ0EsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvZGFtaWFucmFmZmVydHkvUHJvamVjdHMvV290Tm93L3V0aWxzL2FjdGl2aXR5U3VpdGFiaWxpdHkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdXRpbHMvYWN0aXZpdHlTdWl0YWJpbGl0eS50c1xuXG5leHBvcnQgaW50ZXJmYWNlIFdlYXRoZXJEYXRhIHtcbiAgLy8gTGFuZCBjb25kaXRpb25zXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuICBwcmVjaXBpdGF0aW9uPzogbnVtYmVyO1xuICB3aW5kU3BlZWQ/OiBudW1iZXI7XG4gIGNsb3Vkcz86IG51bWJlcjtcbiAgaHVtaWRpdHk/OiBudW1iZXI7XG4gIHZpc2liaWxpdHk/OiBudW1iZXI7XG5cbiAgLy8gTWFyaW5lIGNvbmRpdGlvbnMgKGZyb20gU3Rvcm1nbGFzcylcbiAgd2F0ZXJUZW1wZXJhdHVyZT86IG51bWJlcjsgLy8gQ2Vsc2l1c1xuICB3YXZlSGVpZ2h0PzogbnVtYmVyOyAgICAgICAvLyBNZXRlcnNcbiAgc3dlbGxIZWlnaHQ/OiBudW1iZXI7ICAgICAgLy8gTWV0ZXJzXG4gIHN3ZWxsUGVyaW9kPzogbnVtYmVyOyAgICAgIC8vIFNlY29uZHNcbiAgc3dlbGxEaXJlY3Rpb24/OiBudW1iZXI7ICAgLy8gRGVncmVlc1xuICB3aW5kRGlyZWN0aW9uPzogbnVtYmVyOyAgICAvLyBEZWdyZWVzXG5cbiAgLy8gZmFsbGJhY2tcbiAgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcbn1cblxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSB3ZWF0aGVyIGtleSBuYW1lIGZyb20gYSBjb25kaXRpb24gc3RyaW5nLlxuICogKGUuZy4sIFwidGVtcGVyYXR1cmU+MTVcIiAtPiBcInRlbXBlcmF0dXJlXCIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0V2VhdGhlcktleShjb25kaXRpb246IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHJhbmdlTWF0Y2ggPSBjb25kaXRpb24ubWF0Y2goL14oW2EtekEtWl9dKyk9KC0/XFxkKyg/OlxcLlxcZCspPylcXC5cXC4oLT9cXGQrKD86XFwuXFxkKyk/KS8pO1xuICBpZiAocmFuZ2VNYXRjaCkgcmV0dXJuIHJhbmdlTWF0Y2hbMV07XG4gIGNvbnN0IG9wTWF0Y2ggPSBjb25kaXRpb24ubWF0Y2goL14oW2EtekEtWl9dKylbPD49IV09Py8pO1xuICBpZiAob3BNYXRjaCkgcmV0dXJuIG9wTWF0Y2hbMV07XG4gIHJldHVybiBjb25kaXRpb247XG59XG5cbi8qKlxuICogUGFyc2VzIGEgY29uZGl0aW9uIHN0cmluZyBpbnRvIGtleS9vcGVyYXRvci92YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb25kaXRpb25TdHJpbmcoY29uZGl0aW9uOiBzdHJpbmcpIHtcbiAgY29uc3QgcmFuZ2VNYXRjaCA9IGNvbmRpdGlvbi5tYXRjaCgvXihbYS16QS1aX10rKT0oLT9cXGQrKD86XFwuXFxkKyk/KVxcLlxcLigtP1xcZCsoPzpcXC5cXGQrKT8pLyk7XG4gIGlmIChyYW5nZU1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogcmFuZ2VNYXRjaFsxXSxcbiAgICAgIG9wZXJhdG9yOiAncmFuZ2UnLFxuICAgICAgbWluOiBwYXJzZUZsb2F0KHJhbmdlTWF0Y2hbMl0pLFxuICAgICAgbWF4OiBwYXJzZUZsb2F0KHJhbmdlTWF0Y2hbM10pLFxuICAgIH07XG4gIH1cbiAgY29uc3Qgb3BNYXRjaCA9IGNvbmRpdGlvbi5tYXRjaCgvXihbYS16QS1aX10rKShbPD49IV09P3w9PSkoLT9cXGQrKD86XFwuXFxkKyk/KS8pO1xuICBpZiAob3BNYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IG9wTWF0Y2hbMV0sXG4gICAgICBvcGVyYXRvcjogb3BNYXRjaFsyXSxcbiAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG9wTWF0Y2hbM10pLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIGEgcGFyc2VkIGNvbmRpdGlvbiBhZ2FpbnN0IHdlYXRoZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlQ29uZGl0aW9uKGNvbmRpdGlvbjogc3RyaW5nLCB3ZWF0aGVyOiBXZWF0aGVyRGF0YSk6IGJvb2xlYW4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbmRpdGlvblN0cmluZyhjb25kaXRpb24pO1xuICBpZiAoIXBhcnNlZCkgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IHdlYXRoZXJWYWx1ZSA9IHdlYXRoZXJbcGFyc2VkLmtleV07XG4gIGlmICh3ZWF0aGVyVmFsdWUgPT09IHVuZGVmaW5lZCB8fCB3ZWF0aGVyVmFsdWUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAocGFyc2VkLm9wZXJhdG9yID09PSAncmFuZ2UnKSB7XG4gICAgcmV0dXJuIHdlYXRoZXJWYWx1ZSA+PSBwYXJzZWQubWluICYmIHdlYXRoZXJWYWx1ZSA8PSBwYXJzZWQubWF4O1xuICB9XG5cbiAgc3dpdGNoIChwYXJzZWQub3BlcmF0b3IpIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiB3ZWF0aGVyVmFsdWUgPiBwYXJzZWQudmFsdWU7XG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIHdlYXRoZXJWYWx1ZSA+PSBwYXJzZWQudmFsdWU7XG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gd2VhdGhlclZhbHVlIDwgcGFyc2VkLnZhbHVlO1xuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiB3ZWF0aGVyVmFsdWUgPD0gcGFyc2VkLnZhbHVlO1xuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiB3ZWF0aGVyVmFsdWUgPT09IHBhcnNlZC52YWx1ZTtcbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gd2VhdGhlclZhbHVlICE9PSBwYXJzZWQudmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBvcGVyYXRvcjogJHtwYXJzZWQub3BlcmF0b3J9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHcmFjZWZ1bGx5IGV2YWx1YXRlcyBhIGNvbmRpdGlvbiwgc2tpcHBpbmcgbWlzc2luZyB3ZWF0aGVyIGZpZWxkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVFdmFsdWF0ZShjb25kaXRpb246IHN0cmluZywgd2VhdGhlcjogV2VhdGhlckRhdGEpOiBib29sZWFuIHtcbiAgY29uc3Qga2V5ID0gZXh0cmFjdFdlYXRoZXJLZXkoY29uZGl0aW9uKTtcbiAgY29uc3QgdmFsdWUgPSB3ZWF0aGVyW2tleV07XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gdHJ1ZTsgLy8gVHJlYXQgbWlzc2luZyBmaWVsZHMgYXMgbmV1dHJhbFxuICByZXR1cm4gZXZhbHVhdGVDb25kaXRpb24oY29uZGl0aW9uLCB3ZWF0aGVyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW55IHBvb3IgY29uZGl0aW9uIG1hdGNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNQb29yQ29uZGl0aW9uKGFjdGl2aXR5OiB7IHBvb3JDb25kaXRpb25zPzogc3RyaW5nW10gfSwgd2VhdGhlcjogV2VhdGhlckRhdGEpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhYWN0aXZpdHkucG9vckNvbmRpdGlvbnM/LnNvbWUoY29uZCA9PiBzYWZlRXZhbHVhdGUoY29uZCwgd2VhdGhlcikpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbGwgcGVyZmVjdCBjb25kaXRpb25zIHdpdGgga25vd24gd2VhdGhlciBrZXlzIG1hdGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzUGVyZmVjdENvbmRpdGlvbnMoYWN0aXZpdHk6IHsgcGVyZmVjdENvbmRpdGlvbnM/OiBzdHJpbmdbXSB9LCB3ZWF0aGVyOiBXZWF0aGVyRGF0YSk6IGJvb2xlYW4ge1xuICByZXR1cm4gISFhY3Rpdml0eS5wZXJmZWN0Q29uZGl0aW9ucz8ubGVuZ3RoICYmXG4gICAgYWN0aXZpdHkucGVyZmVjdENvbmRpdGlvbnMuZXZlcnkoY29uZCA9PiBzYWZlRXZhbHVhdGUoY29uZCwgd2VhdGhlcikpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbGwgZ29vZCBjb25kaXRpb25zIHdpdGgga25vd24gd2VhdGhlciBrZXlzIG1hdGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzR29vZENvbmRpdGlvbnMoYWN0aXZpdHk6IHsgZ29vZENvbmRpdGlvbnM/OiBzdHJpbmdbXSB9LCB3ZWF0aGVyOiBXZWF0aGVyRGF0YSk6IGJvb2xlYW4ge1xuICByZXR1cm4gISFhY3Rpdml0eS5nb29kQ29uZGl0aW9ucz8ubGVuZ3RoICYmXG4gICAgYWN0aXZpdHkuZ29vZENvbmRpdGlvbnMuZXZlcnkoY29uZCA9PiBzYWZlRXZhbHVhdGUoY29uZCwgd2VhdGhlcikpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1aXRhYmlsaXR5IGxldmVsIG9mIGFuIGFjdGl2aXR5IGZvciB0aGUgZ2l2ZW4gd2VhdGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGl2aXR5U3VpdGFiaWxpdHkoXG4gIGFjdGl2aXR5OiBhbnksXG4gIHdlYXRoZXI6IFdlYXRoZXJEYXRhXG4pOiBcImV4Y2x1ZGVkXCIgfCBcInBlcmZlY3RcIiB8IFwiZ29vZFwiIHwgXCJhY2NlcHRhYmxlXCIgfCBcImluZG9vclwiIHtcbiAgaWYgKGFjdGl2aXR5LndlYXRoZXJTZW5zaXRpdmUgPT09IGZhbHNlKSByZXR1cm4gXCJpbmRvb3JcIjtcbiAgaWYgKGhhc1Bvb3JDb25kaXRpb24oYWN0aXZpdHksIHdlYXRoZXIpKSByZXR1cm4gXCJleGNsdWRlZFwiO1xuICBpZiAoaGFzUGVyZmVjdENvbmRpdGlvbnMoYWN0aXZpdHksIHdlYXRoZXIpKSByZXR1cm4gXCJwZXJmZWN0XCI7XG4gIGlmIChoYXNHb29kQ29uZGl0aW9ucyhhY3Rpdml0eSwgd2VhdGhlcikpIHJldHVybiBcImdvb2RcIjtcbiAgaWYgKFxuICAgICghYWN0aXZpdHkuZ29vZENvbmRpdGlvbnMgfHwgYWN0aXZpdHkuZ29vZENvbmRpdGlvbnMubGVuZ3RoID09PSAwKSAmJlxuICAgICghYWN0aXZpdHkucGVyZmVjdENvbmRpdGlvbnMgfHwgYWN0aXZpdHkucGVyZmVjdENvbmRpdGlvbnMubGVuZ3RoID09PSAwKVxuICApIHtcbiAgICByZXR1cm4gXCJhY2NlcHRhYmxlXCI7XG4gIH1cbiAgcmV0dXJuIFwiZXhjbHVkZWRcIjtcbn1cbiJdLCJuYW1lcyI6WyJleHRyYWN0V2VhdGhlcktleSIsImNvbmRpdGlvbiIsInJhbmdlTWF0Y2giLCJtYXRjaCIsIm9wTWF0Y2giLCJwYXJzZUNvbmRpdGlvblN0cmluZyIsImtleSIsIm9wZXJhdG9yIiwibWluIiwicGFyc2VGbG9hdCIsIm1heCIsInZhbHVlIiwiZXZhbHVhdGVDb25kaXRpb24iLCJ3ZWF0aGVyIiwicGFyc2VkIiwid2VhdGhlclZhbHVlIiwidW5kZWZpbmVkIiwiY29uc29sZSIsIndhcm4iLCJzYWZlRXZhbHVhdGUiLCJoYXNQb29yQ29uZGl0aW9uIiwiYWN0aXZpdHkiLCJwb29yQ29uZGl0aW9ucyIsInNvbWUiLCJjb25kIiwiaGFzUGVyZmVjdENvbmRpdGlvbnMiLCJwZXJmZWN0Q29uZGl0aW9ucyIsImxlbmd0aCIsImV2ZXJ5IiwiaGFzR29vZENvbmRpdGlvbnMiLCJnb29kQ29uZGl0aW9ucyIsImdldEFjdGl2aXR5U3VpdGFiaWxpdHkiLCJ3ZWF0aGVyU2Vuc2l0aXZlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/activitySuitability.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./utils/getSuggestionsByDay.ts":
/*!**************************************!*\
  !*** ./utils/getSuggestionsByDay.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSuggestionsByDay: () => (/* binding */ getSuggestionsByDay)\n/* harmony export */ });\n/* harmony import */ var _activitySuitability__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activitySuitability */ \"(pages-dir-browser)/./utils/activitySuitability.ts\");\n\n// --- Main Function ---\n/**\n * Suggests up to 10 activities per day:\n * 1) Outdoor with perfect conditions (land & marine aware)\n * 2) Outdoor with good/acceptable conditions\n * 3) Indoor alternatives\n * 4) Indoor, weather-irrelevant interests\n */ function getSuggestionsByDay(param) {\n    let { forecast = [], interests = [], activities = [] } = param;\n    if (!Array.isArray(activities) || !Array.isArray(forecast)) return [];\n    return forecast.map((day)=>{\n        // --- Merge land and marine weather ---\n        const marine = Array.isArray(day.marine) && day.marine.length > 0 ? day.marine[0] : {};\n        const weather = {\n            ...day.weather,\n            ...marine\n        };\n        const currentMonth = new Date(day.date).getMonth() + 1;\n        const selected = activities.filter((a)=>interests.includes(a.id) && (!a.seasonalMonths || a.seasonalMonths.includes(currentMonth)));\n        const perfect = [];\n        const good = [];\n        const indoorAlternatives = [];\n        const indoor = [];\n        // -- Evaluate activity suitability --\n        for (const activity of selected){\n            const { id, weatherSensitive, indoorAlternative } = activity;\n            const suitability = (0,_activitySuitability__WEBPACK_IMPORTED_MODULE_0__.getActivitySuitability)(activity, weather);\n            if (suitability === 'excluded') continue;\n            if (suitability === 'perfect') {\n                perfect.push({\n                    activityId: id,\n                    evaluation: 'perfect'\n                });\n            } else if (suitability === 'good') {\n                good.push({\n                    activityId: id,\n                    evaluation: 'good'\n                });\n            } else if (suitability === 'acceptable') {\n                good.push({\n                    activityId: id,\n                    evaluation: 'acceptable'\n                });\n            } else if (suitability === 'indoor') {\n                indoor.push({\n                    activityId: id,\n                    evaluation: 'indoor'\n                });\n            }\n            if (weatherSensitive && indoorAlternative) indoorAlternatives.push(indoorAlternative);\n        }\n        // -- Order suggestions: perfect, good/acceptable, indoor alt, then indoor --\n        const suggestions = [];\n        const seen = new Set();\n        function add(list) {\n            for (const i of list){\n                if (!seen.has(i.activityId) && suggestions.length < 10) {\n                    seen.add(i.activityId);\n                    suggestions.push(i);\n                }\n            }\n        }\n        add(perfect);\n        add(good);\n        // Add indoor alternatives (limit to 10)\n        if (suggestions.length < 10 && indoorAlternatives.length > 0) {\n            for (const alt of indoorAlternatives){\n                const altActivity = activities.find((a)=>a.id === alt || a.name === alt);\n                if (altActivity && !seen.has(altActivity.id)) {\n                    suggestions.push({\n                        activityId: altActivity.id,\n                        evaluation: 'indoorAlternative'\n                    });\n                    seen.add(altActivity.id);\n                    if (suggestions.length >= 10) break;\n                }\n            }\n        }\n        if (suggestions.length < 10) {\n            for (const i of indoor){\n                if (!seen.has(i.activityId)) {\n                    suggestions.push(i);\n                    seen.add(i.activityId);\n                    if (suggestions.length >= 10) break;\n                }\n            }\n        }\n        return {\n            date: day.date,\n            suggestions\n        };\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL2dldFN1Z2dlc3Rpb25zQnlEYXkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0Q7QUFnRC9ELHdCQUF3QjtBQUN4Qjs7Ozs7O0NBTUMsR0FDTSxTQUFTQyxvQkFBb0IsS0FJUjtRQUpRLEVBQ2xDQyxXQUFXLEVBQUUsRUFDYkMsWUFBWSxFQUFFLEVBQ2RDLGFBQWEsRUFBRSxFQUNXLEdBSlE7SUFLbEMsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLGVBQWUsQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixXQUFXLE9BQU8sRUFBRTtJQUVyRSxPQUFPQSxTQUFTSyxHQUFHLENBQUNDLENBQUFBO1FBQ2xCLHdDQUF3QztRQUN4QyxNQUFNQyxTQUFTSixNQUFNQyxPQUFPLENBQUNFLElBQUlDLE1BQU0sS0FBS0QsSUFBSUMsTUFBTSxDQUFDQyxNQUFNLEdBQUcsSUFBSUYsSUFBSUMsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ3JGLE1BQU1FLFVBQXVCO1lBQUUsR0FBR0gsSUFBSUcsT0FBTztZQUFFLEdBQUdGLE1BQU07UUFBQztRQUV6RCxNQUFNRyxlQUFlLElBQUlDLEtBQUtMLElBQUlNLElBQUksRUFBRUMsUUFBUSxLQUFLO1FBQ3JELE1BQU1DLFdBQVdaLFdBQVdhLE1BQU0sQ0FDaENDLENBQUFBLElBQUtmLFVBQVVnQixRQUFRLENBQUNELEVBQUVFLEVBQUUsS0FDdEIsRUFBQ0YsRUFBRUcsY0FBYyxJQUFJSCxFQUFFRyxjQUFjLENBQUNGLFFBQVEsQ0FBQ1AsYUFBWTtRQUduRSxNQUFNVSxVQUF3QixFQUFFO1FBQ2hDLE1BQU1DLE9BQXFCLEVBQUU7UUFDN0IsTUFBTUMscUJBQStCLEVBQUU7UUFDdkMsTUFBTUMsU0FBdUIsRUFBRTtRQUUvQixzQ0FBc0M7UUFDdEMsS0FBSyxNQUFNQyxZQUFZVixTQUFVO1lBQy9CLE1BQU0sRUFBRUksRUFBRSxFQUFFTyxnQkFBZ0IsRUFBRUMsaUJBQWlCLEVBQUUsR0FBR0Y7WUFDcEQsTUFBTUcsY0FBYzdCLDRFQUFzQkEsQ0FBQzBCLFVBQVVmO1lBRXJELElBQUlrQixnQkFBZ0IsWUFBWTtZQUNoQyxJQUFJQSxnQkFBZ0IsV0FBVztnQkFDN0JQLFFBQVFRLElBQUksQ0FBQztvQkFBRUMsWUFBWVg7b0JBQUlZLFlBQVk7Z0JBQVU7WUFDdkQsT0FBTyxJQUFJSCxnQkFBZ0IsUUFBUTtnQkFDakNOLEtBQUtPLElBQUksQ0FBQztvQkFBRUMsWUFBWVg7b0JBQUlZLFlBQVk7Z0JBQU87WUFDakQsT0FBTyxJQUFJSCxnQkFBZ0IsY0FBYztnQkFDdkNOLEtBQUtPLElBQUksQ0FBQztvQkFBRUMsWUFBWVg7b0JBQUlZLFlBQVk7Z0JBQWE7WUFDdkQsT0FBTyxJQUFJSCxnQkFBZ0IsVUFBVTtnQkFDbkNKLE9BQU9LLElBQUksQ0FBQztvQkFBRUMsWUFBWVg7b0JBQUlZLFlBQVk7Z0JBQVM7WUFDckQ7WUFFQSxJQUFJTCxvQkFBb0JDLG1CQUFtQkosbUJBQW1CTSxJQUFJLENBQUNGO1FBQ3JFO1FBRUEsNkVBQTZFO1FBQzdFLE1BQU1LLGNBQTRCLEVBQUU7UUFDcEMsTUFBTUMsT0FBTyxJQUFJQztRQUNqQixTQUFTQyxJQUFJQyxJQUFrQjtZQUM3QixLQUFLLE1BQU1DLEtBQUtELEtBQU07Z0JBQ3BCLElBQUksQ0FBQ0gsS0FBS0ssR0FBRyxDQUFDRCxFQUFFUCxVQUFVLEtBQUtFLFlBQVl2QixNQUFNLEdBQUcsSUFBSTtvQkFDdER3QixLQUFLRSxHQUFHLENBQUNFLEVBQUVQLFVBQVU7b0JBQ3JCRSxZQUFZSCxJQUFJLENBQUNRO2dCQUNuQjtZQUNGO1FBQ0Y7UUFDQUYsSUFBSWQ7UUFBVWMsSUFBSWI7UUFFbEIsd0NBQXdDO1FBQ3hDLElBQUlVLFlBQVl2QixNQUFNLEdBQUcsTUFBTWMsbUJBQW1CZCxNQUFNLEdBQUcsR0FBRztZQUM1RCxLQUFLLE1BQU04QixPQUFPaEIsbUJBQW9CO2dCQUNwQyxNQUFNaUIsY0FBY3JDLFdBQVdzQyxJQUFJLENBQUN4QixDQUFBQSxJQUFLQSxFQUFFRSxFQUFFLEtBQUtvQixPQUFPdEIsRUFBRXlCLElBQUksS0FBS0g7Z0JBQ3BFLElBQUlDLGVBQWUsQ0FBQ1AsS0FBS0ssR0FBRyxDQUFDRSxZQUFZckIsRUFBRSxHQUFHO29CQUM1Q2EsWUFBWUgsSUFBSSxDQUFDO3dCQUFFQyxZQUFZVSxZQUFZckIsRUFBRTt3QkFBRVksWUFBWTtvQkFBb0I7b0JBQy9FRSxLQUFLRSxHQUFHLENBQUNLLFlBQVlyQixFQUFFO29CQUN2QixJQUFJYSxZQUFZdkIsTUFBTSxJQUFJLElBQUk7Z0JBQ2hDO1lBQ0Y7UUFDRjtRQUNBLElBQUl1QixZQUFZdkIsTUFBTSxHQUFHLElBQUk7WUFDM0IsS0FBSyxNQUFNNEIsS0FBS2IsT0FBUTtnQkFDdEIsSUFBSSxDQUFDUyxLQUFLSyxHQUFHLENBQUNELEVBQUVQLFVBQVUsR0FBRztvQkFDM0JFLFlBQVlILElBQUksQ0FBQ1E7b0JBQ2pCSixLQUFLRSxHQUFHLENBQUNFLEVBQUVQLFVBQVU7b0JBQ3JCLElBQUlFLFlBQVl2QixNQUFNLElBQUksSUFBSTtnQkFDaEM7WUFDRjtRQUNGO1FBRUEsT0FBTztZQUFFSSxNQUFNTixJQUFJTSxJQUFJO1lBQUVtQjtRQUFZO0lBQ3ZDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYW1pYW5yYWZmZXJ0eS9Qcm9qZWN0cy9Xb3ROb3cvdXRpbHMvZ2V0U3VnZ2VzdGlvbnNCeURheS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBY3Rpdml0eVN1aXRhYmlsaXR5IH0gZnJvbSAnLi9hY3Rpdml0eVN1aXRhYmlsaXR5JztcbmltcG9ydCB7IEFjdGl2aXR5VHlwZSB9IGZyb20gJy4uL2RhdGEvYWN0aXZpdHlUeXBlcyc7XG5cbi8vIC0tLSBUeXBlcyAtLS1cbmV4cG9ydCB0eXBlIFN1aXRhYmlsaXR5TGV2ZWwgPSAncGVyZmVjdCcgfCAnZ29vZCcgfCAnYWNjZXB0YWJsZScgfCAnaW5kb29yJyB8ICdpbmRvb3JBbHRlcm5hdGl2ZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2VhdGhlckRhdGEge1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbiAgcHJlY2lwaXRhdGlvbj86IG51bWJlcjtcbiAgd2luZFNwZWVkPzogbnVtYmVyO1xuICB3YXRlclRlbXBlcmF0dXJlPzogbnVtYmVyOyAvLyBTdG9ybWdsYXNzXG4gIHdhdmVIZWlnaHQ/OiBudW1iZXI7ICAgICAgIC8vIFN0b3JtZ2xhc3NcbiAgc3dlbGxIZWlnaHQ/OiBudW1iZXI7XG4gIHN3ZWxsUGVyaW9kPzogbnVtYmVyO1xuICBjbG91ZHM/OiBudW1iZXI7XG4gIGh1bWlkaXR5PzogbnVtYmVyO1xuICB2aXNpYmlsaXR5PzogbnVtYmVyO1xuICBba2V5OiBzdHJpbmddOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcmluZVdlYXRoZXJEYXRhIHtcbiAgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcbiAgLy8gWW91IGNhbiBleHRlbmQgd2l0aCBleHBsaWNpdCBwcm9wZXJ0aWVzIGlmIGRlc2lyZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb3JlY2FzdERheUlucHV0IHtcbiAgZGF0ZTogc3RyaW5nO1xuICB3ZWF0aGVyOiBXZWF0aGVyRGF0YTtcbiAgbWFyaW5lPzogTWFyaW5lV2VhdGhlckRhdGFbXTsgLy8gRWFjaCBkYXkgY2FuIGluY2x1ZGUgbWFyaW5lIGRhdGEgYXJyYXlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uIHtcbiAgYWN0aXZpdHlJZDogc3RyaW5nO1xuICBldmFsdWF0aW9uOiBTdWl0YWJpbGl0eUxldmVsO1xuICBzY29yZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uc0ZvckRheSB7XG4gIGRhdGU6IHN0cmluZztcbiAgc3VnZ2VzdGlvbnM6IFN1Z2dlc3Rpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRTdWdnZXN0aW9uc0J5RGF5UGFyYW1zIHtcbiAgZm9yZWNhc3Q6IEZvcmVjYXN0RGF5SW5wdXRbXTtcbiAgaW50ZXJlc3RzOiBzdHJpbmdbXTtcbiAgYWN0aXZpdGllczogQWN0aXZpdHlUeXBlW107XG59XG5cbi8vIC0tLSBNYWluIEZ1bmN0aW9uIC0tLVxuLyoqXG4gKiBTdWdnZXN0cyB1cCB0byAxMCBhY3Rpdml0aWVzIHBlciBkYXk6XG4gKiAxKSBPdXRkb29yIHdpdGggcGVyZmVjdCBjb25kaXRpb25zIChsYW5kICYgbWFyaW5lIGF3YXJlKVxuICogMikgT3V0ZG9vciB3aXRoIGdvb2QvYWNjZXB0YWJsZSBjb25kaXRpb25zXG4gKiAzKSBJbmRvb3IgYWx0ZXJuYXRpdmVzXG4gKiA0KSBJbmRvb3IsIHdlYXRoZXItaXJyZWxldmFudCBpbnRlcmVzdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN1Z2dlc3Rpb25zQnlEYXkoe1xuICBmb3JlY2FzdCA9IFtdLFxuICBpbnRlcmVzdHMgPSBbXSxcbiAgYWN0aXZpdGllcyA9IFtdLFxufTogR2V0U3VnZ2VzdGlvbnNCeURheVBhcmFtcyk6IFN1Z2dlc3Rpb25zRm9yRGF5W10ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYWN0aXZpdGllcykgfHwgIUFycmF5LmlzQXJyYXkoZm9yZWNhc3QpKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIGZvcmVjYXN0Lm1hcChkYXkgPT4ge1xuICAgIC8vIC0tLSBNZXJnZSBsYW5kIGFuZCBtYXJpbmUgd2VhdGhlciAtLS1cbiAgICBjb25zdCBtYXJpbmUgPSBBcnJheS5pc0FycmF5KGRheS5tYXJpbmUpICYmIGRheS5tYXJpbmUubGVuZ3RoID4gMCA/IGRheS5tYXJpbmVbMF0gOiB7fTtcbiAgICBjb25zdCB3ZWF0aGVyOiBXZWF0aGVyRGF0YSA9IHsgLi4uZGF5LndlYXRoZXIsIC4uLm1hcmluZSB9O1xuXG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoZGF5LmRhdGUpLmdldE1vbnRoKCkgKyAxO1xuICAgIGNvbnN0IHNlbGVjdGVkID0gYWN0aXZpdGllcy5maWx0ZXIoXG4gICAgICBhID0+IGludGVyZXN0cy5pbmNsdWRlcyhhLmlkKSAmJlxuICAgICAgICAgICAoIWEuc2Vhc29uYWxNb250aHMgfHwgYS5zZWFzb25hbE1vbnRocy5pbmNsdWRlcyhjdXJyZW50TW9udGgpKVxuICAgICk7XG5cbiAgICBjb25zdCBwZXJmZWN0OiBTdWdnZXN0aW9uW10gPSBbXTtcbiAgICBjb25zdCBnb29kOiBTdWdnZXN0aW9uW10gPSBbXTtcbiAgICBjb25zdCBpbmRvb3JBbHRlcm5hdGl2ZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgaW5kb29yOiBTdWdnZXN0aW9uW10gPSBbXTtcblxuICAgIC8vIC0tIEV2YWx1YXRlIGFjdGl2aXR5IHN1aXRhYmlsaXR5IC0tXG4gICAgZm9yIChjb25zdCBhY3Rpdml0eSBvZiBzZWxlY3RlZCkge1xuICAgICAgY29uc3QgeyBpZCwgd2VhdGhlclNlbnNpdGl2ZSwgaW5kb29yQWx0ZXJuYXRpdmUgfSA9IGFjdGl2aXR5O1xuICAgICAgY29uc3Qgc3VpdGFiaWxpdHkgPSBnZXRBY3Rpdml0eVN1aXRhYmlsaXR5KGFjdGl2aXR5LCB3ZWF0aGVyKTtcblxuICAgICAgaWYgKHN1aXRhYmlsaXR5ID09PSAnZXhjbHVkZWQnKSBjb250aW51ZTtcbiAgICAgIGlmIChzdWl0YWJpbGl0eSA9PT0gJ3BlcmZlY3QnKSB7XG4gICAgICAgIHBlcmZlY3QucHVzaCh7IGFjdGl2aXR5SWQ6IGlkLCBldmFsdWF0aW9uOiAncGVyZmVjdCcgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN1aXRhYmlsaXR5ID09PSAnZ29vZCcpIHtcbiAgICAgICAgZ29vZC5wdXNoKHsgYWN0aXZpdHlJZDogaWQsIGV2YWx1YXRpb246ICdnb29kJyB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3VpdGFiaWxpdHkgPT09ICdhY2NlcHRhYmxlJykge1xuICAgICAgICBnb29kLnB1c2goeyBhY3Rpdml0eUlkOiBpZCwgZXZhbHVhdGlvbjogJ2FjY2VwdGFibGUnIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdWl0YWJpbGl0eSA9PT0gJ2luZG9vcicpIHtcbiAgICAgICAgaW5kb29yLnB1c2goeyBhY3Rpdml0eUlkOiBpZCwgZXZhbHVhdGlvbjogJ2luZG9vcicgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3ZWF0aGVyU2Vuc2l0aXZlICYmIGluZG9vckFsdGVybmF0aXZlKSBpbmRvb3JBbHRlcm5hdGl2ZXMucHVzaChpbmRvb3JBbHRlcm5hdGl2ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0gT3JkZXIgc3VnZ2VzdGlvbnM6IHBlcmZlY3QsIGdvb2QvYWNjZXB0YWJsZSwgaW5kb29yIGFsdCwgdGhlbiBpbmRvb3IgLS1cbiAgICBjb25zdCBzdWdnZXN0aW9uczogU3VnZ2VzdGlvbltdID0gW107XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGZ1bmN0aW9uIGFkZChsaXN0OiBTdWdnZXN0aW9uW10pIHtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBsaXN0KSB7XG4gICAgICAgIGlmICghc2Vlbi5oYXMoaS5hY3Rpdml0eUlkKSAmJiBzdWdnZXN0aW9ucy5sZW5ndGggPCAxMCkge1xuICAgICAgICAgIHNlZW4uYWRkKGkuYWN0aXZpdHlJZCk7XG4gICAgICAgICAgc3VnZ2VzdGlvbnMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhZGQocGVyZmVjdCk7IGFkZChnb29kKTtcblxuICAgIC8vIEFkZCBpbmRvb3IgYWx0ZXJuYXRpdmVzIChsaW1pdCB0byAxMClcbiAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoIDwgMTAgJiYgaW5kb29yQWx0ZXJuYXRpdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgYWx0IG9mIGluZG9vckFsdGVybmF0aXZlcykge1xuICAgICAgICBjb25zdCBhbHRBY3Rpdml0eSA9IGFjdGl2aXRpZXMuZmluZChhID0+IGEuaWQgPT09IGFsdCB8fCBhLm5hbWUgPT09IGFsdCk7XG4gICAgICAgIGlmIChhbHRBY3Rpdml0eSAmJiAhc2Vlbi5oYXMoYWx0QWN0aXZpdHkuaWQpKSB7XG4gICAgICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7IGFjdGl2aXR5SWQ6IGFsdEFjdGl2aXR5LmlkLCBldmFsdWF0aW9uOiAnaW5kb29yQWx0ZXJuYXRpdmUnIH0pO1xuICAgICAgICAgIHNlZW4uYWRkKGFsdEFjdGl2aXR5LmlkKTtcbiAgICAgICAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoID49IDEwKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoIDwgMTApIHtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBpbmRvb3IpIHtcbiAgICAgICAgaWYgKCFzZWVuLmhhcyhpLmFjdGl2aXR5SWQpKSB7XG4gICAgICAgICAgc3VnZ2VzdGlvbnMucHVzaChpKTtcbiAgICAgICAgICBzZWVuLmFkZChpLmFjdGl2aXR5SWQpO1xuICAgICAgICAgIGlmIChzdWdnZXN0aW9ucy5sZW5ndGggPj0gMTApIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZGF0ZTogZGF5LmRhdGUsIHN1Z2dlc3Rpb25zIH07XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbImdldEFjdGl2aXR5U3VpdGFiaWxpdHkiLCJnZXRTdWdnZXN0aW9uc0J5RGF5IiwiZm9yZWNhc3QiLCJpbnRlcmVzdHMiLCJhY3Rpdml0aWVzIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZGF5IiwibWFyaW5lIiwibGVuZ3RoIiwid2VhdGhlciIsImN1cnJlbnRNb250aCIsIkRhdGUiLCJkYXRlIiwiZ2V0TW9udGgiLCJzZWxlY3RlZCIsImZpbHRlciIsImEiLCJpbmNsdWRlcyIsImlkIiwic2Vhc29uYWxNb250aHMiLCJwZXJmZWN0IiwiZ29vZCIsImluZG9vckFsdGVybmF0aXZlcyIsImluZG9vciIsImFjdGl2aXR5Iiwid2VhdGhlclNlbnNpdGl2ZSIsImluZG9vckFsdGVybmF0aXZlIiwic3VpdGFiaWxpdHkiLCJwdXNoIiwiYWN0aXZpdHlJZCIsImV2YWx1YXRpb24iLCJzdWdnZXN0aW9ucyIsInNlZW4iLCJTZXQiLCJhZGQiLCJsaXN0IiwiaSIsImhhcyIsImFsdCIsImFsdEFjdGl2aXR5IiwiZmluZCIsIm5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/getSuggestionsByDay.ts\n"));

/***/ })

});